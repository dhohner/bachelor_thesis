<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>A CBC Casper Tutorial</title>
  <meta name="description" content="Special thanks to Vlad Zamfir, Aditya Asgaonkar, Ameen Soleimani and Jinglan Wang for review">

  <link rel="stylesheet" href="A%20CBC%20Casper%20Tutorial-Dateien/main.css">
  <link rel="canonical" href="https://vitalik.ca/general/2018/12/05/cbc_casper.html">
  <link rel="alternate" type="application/rss+xml" title="Vitalik Buterin's website" href="https://vitalik.ca/feed.xml">
<style>@media print {#ghostery-purple-box {display:none !important}}</style></head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="https://vitalik.ca/">Vitalik Buterin's website</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="https://vitalik.ca/2017-09-15-prehistory.html">A Prehistory of the Ethereum Protocol</a>
          
        
          
          <a class="page-link" href="https://vitalik.ca/about/">About</a>
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope="" itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">A CBC Casper Tutorial</h1>
    <p class="post-meta"><time datetime="2018-12-05T17:03:10-08:00" itemprop="datePublished">Dec 5, 2018</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p><em>Special thanks to Vlad Zamfir, Aditya Asgaonkar, Ameen Soleimani and Jinglan Wang for review</em></p>

<p>In order to help more people understand “the other Casper” (Vlad 
Zamfir’s CBC Casper), and specifically the instantiation that works best
 for blockchain protocols, I thought that I would write an explainer on 
it myself, from a less abstract and more “close to concrete usage” point
 of view. Vlad’s descriptions of CBC Casper can be found <a href="https://www.youtube.com/watch?v=GNGbd_RbrzE">here</a> and <a href="https://github.com/ethereum/cbc-casper/wiki/FAQ">here</a> and <a href="https://github.com/cbc-casper/cbc-casper-paper">here</a>; you are welcome and encouraged to look through these materials as well.</p>

<p>CBC Casper is designed to be fundamentally very versatile and 
abstract, and come to consensus on pretty much any data structure; you 
can use CBC to decide whether to choose 0 or 1, you can make a simple 
block-by-block chain run on top of CBC, or a 2<sup>92</sup>-dimensional hypercube tangle DAG, and pretty much anything in between.</p>

<p>But for simplicity, we will first focus our attention on one concrete
 case: a simple chain-based structure. We will suppose that there is a 
fixed validator set consisting of N validators (a fancy word for 
“staking nodes”; we also assume that each node is staking the same 
amount of coins, cases where this is not true can be simulated by 
assigning some nodes multiple validator IDs), time is broken up into 
ten-second slots, and validator <code class="highlighter-rouge">k</code> can create a block in slot <code class="highlighter-rouge">k</code>, <code class="highlighter-rouge">N + k</code>, <code class="highlighter-rouge">2N + k</code>,
 etc. Each block points to one specific parent block. Clearly, if we 
wanted to make something maximally simple, we could just take this 
structure, impose a longest chain rule on top of it, and call it a day.</p>

<center>
<img src="A%20CBC%20Casper%20Tutorial-Dateien/Chain3.png"><br>
<small><i>The green chain is the longest chain (length 6) so it is considered to be the "canonical chain".</i></small>
</center>

<p><br></p>

<p>However, what we care about here is adding some notion of “finality” -
 the idea that some block can be so firmly established in the chain that
 it cannot be overtaken by a competing block unless a very large portion
 (eg. 1/4) of validators commit a <em>uniquely attributable fault</em> - act in some way which is clearly and cryptographically verifiably malicious. If a very large portion of validators <em>do</em>
 act maliciously to revert the block, proof of the misbehavior can be 
submitted to the chain to take away those validators’ entire deposits, 
making the reversion of finality extremely expensive (think hundreds of 
millions of dollars).</p>

<h3 id="lmd-ghost">LMD GHOST</h3>

<p>We will take this one step at a time. First, we replace the fork 
choice rule (the rule that chooses which chain among many possible 
choices is “the canonical chain”, ie. the chain that users should care 
about), moving away from the simple longest-chain-rule and instead using
 “latest message driven GHOST”. To show how LMD GHOST works, we will 
modify the above example. To make it more concrete, suppose the 
validator set has size 5, which we label A, B, C, D, E, so validator A 
makes the blocks at slots 0 and 5, validator B at slots 1 and 6, etc. A 
client evaluating the LMD GHOST fork choice rule cares only about the 
most recent (ie. highest-slot) message (ie. block) signed by each 
validator:</p>

<center>
<img src="A%20CBC%20Casper%20Tutorial-Dateien/Chain4.png"><br>
<small><i>Latest messages in blue, slots from left to right (eg. A's block on the left is at slot 0, etc.)</i></small>
</center>
<p><br></p>

<p>Now, we will use only these messages as source data for the “greedy 
heaviest observed subtree” (GHOST) fork choice rule: start at the 
genesis block, then each time there is a fork choose the side where more
 of the latest messages support that block’s subtree (ie. more of the 
latest messages support either that block or one of its descendants), 
and keep doing this until you reach a block with no children. We can 
compute for each block the subset of latest messages that support either
 the block or one of its descendants:</p>

<center>
<img src="A%20CBC%20Casper%20Tutorial-Dateien/Chain5.png"><br>
</center>

<p>Now, to compute the head, we start at the beginning, and then at each
 fork pick the higher number: first, pick the bottom chain as it has 4 
latest messages supporting it versus 1 for the single-block top chain, 
then at the next fork support the middle chain. The result is the same 
longest chain as before. Indeed, in a well-running network (ie. the 
orphan rate is low), almost all of the time LMD GHOST and the longest 
chain rule <em>will</em> give the exact same answer. But in more extreme
 circumstances, this is not always true. For example, consider the 
following chain, with a more substantial three-block fork:</p>

<center>
<img src="A%20CBC%20Casper%20Tutorial-Dateien/Chain6.png"><br>
<small><i>Scoring blocks by chain length. If we follow the longest chain rule, the top chain is longer, so the top chain wins.</i></small>
</center>
<p><br></p>
<center>
<img src="A%20CBC%20Casper%20Tutorial-Dateien/Chain7.png"><br>
<small><i>Scoring blocks by number of supporting latest messages and 
using the GHOST rule (latest message from each validator shown in blue).
 The bottom chain has more recent support, so if we follow the LMD GHOST
 rule the bottom chain wins, though it's not yet clear which of the 
three blocks takes precedence.</i></small>
</center>
<p><br></p>

<p>The LMD GHOST approach is advantageous in part because it is better 
at extracting information in conditions of high latency. If two 
validators create two blocks with the same parent, they should really be
 both counted as cooperating votes for the parent block, even though 
they are at the same time competing votes for themselves. The longest 
chain rule fails to capture this nuance; GHOST-based rules do.</p>

<h3 id="detecting-finality">Detecting finality</h3>

<p>But the LMD GHOST approach has another nice property: it’s <em>sticky</em>.
 For example, suppose that for two rounds, 4/5 of validators voted for 
the same chain (we’ll assume that the one of the five validators that 
did not, B, is attacking):</p>

<center>
<img src="A%20CBC%20Casper%20Tutorial-Dateien/Chain8.png"><br>
</center>
<p><br></p>

<p>What would need to actually happen for the chain on top to become the
 canonical chain? Four of five validators built on top of E’s first 
block, and all four recognized that E had a high score in the LMD fork 
choice. Just by looking at the structure of the chain, we can know for a
 fact at least some of the messages that the validators must have seen 
at different times. Here is what we know about the four validators’ 
views:</p>

<center>
<table style="text-align:center" cellpadding="20px"><tbody><tr>
<td><img src="A%20CBC%20Casper%20Tutorial-Dateien/Chain9.png" width="300px"><br><i>A's view</i></td>
<td><img src="A%20CBC%20Casper%20Tutorial-Dateien/Chain10.png" width="300px"><br><i>C's view</i></td>
</tr><tr>
<td><img src="A%20CBC%20Casper%20Tutorial-Dateien/Chain11.png" width="300px"><br><i>D's view</i></td>
<td><img src="A%20CBC%20Casper%20Tutorial-Dateien/Chain11point5.png" width="300px"><br><i>E's view</i></td>
</tr></tbody></table>
<small><i>Blocks produced by each validator in green, the latest messages we know that they saw from each of the other validators in blue.</i></small>
</center>
<p><br></p>

<p>Note that all four of the validators <em>could have</em> seen one or both of B’s blocks, and D and E <em>could have</em>
 seen C’s second block, making that the latest message in their views 
instead of C’s first block; however, the structure of the chain itself 
gives us no evidence that they actually did. Fortunately, as we will see
 below, this ambiguity does not matter for us.</p>

<p>A’s view contains four latest-messages supporting the bottom chain, 
and none supporting B’s block. Hence, in (our simulation of) A’s eyes 
the score in favor of the bottom chain is <em>at least</em> 4-1. The 
views of C, D and E paint a similar picture, with four latest-messages 
supporting the bottom chain. Hence, all four of the validators are in a 
position where they cannot change their minds unless two other 
validators change their minds first to bring the score to 2-3 in favor 
of B’s block.</p>

<p>Note that our simulation of the validators’ views is “out of date” in
 that, for example, it does not capture that D and E could have seen the
 more recent block by C. However, this does not alter the calculation 
for the top vs bottom chain, because we can very generally say that any 
validator’s new message will have the same opinion as their previous 
messages, unless two other validators have already switched sides first.</p>

<center>
<img src="A%20CBC%20Casper%20Tutorial-Dateien/Chain12.png" width="700px"><br>
<small><i>A minimal viable attack. A and C illegally switch over to 
support B's block (and can get penalized for this), giving it a 3-2 
advantage, and at this point it becomes legal for D and E to also switch
 over.</i></small>
</center>
<p><br></p>

<p>Since fork choice rules such as LMD GHOST are sticky in this way, and
 clients can detect when the fork choice rule is “stuck on” a particular
 block, we can use this as a way of achieving asynchronously safe 
consensus.</p>

<h3 id="safety-oracles">Safety Oracles</h3>

<p>Actually detecting all possible situations where the chain becomes 
stuck on some block (in CBC lingo, the block is “decided” or “safe”) is 
very difficult, but we can come up with a set of heuristics (“safety 
oracles”) which will help us detect <em>some</em> of the cases where this happens. The simplest of these is the <strong>clique oracle</strong>. If there exists some subset <code class="highlighter-rouge">V</code> of the validators making up portion <code class="highlighter-rouge">p</code> of the total validator set (with <code class="highlighter-rouge">p &gt; 1/2</code>) that all make blocks supporting some block <code class="highlighter-rouge">B</code> and then make another round of blocks still supporting <code class="highlighter-rouge">B</code> that references their first round of blocks, then we can reason as follows:</p>

<p>Because of the two rounds of messaging, we know that this subset <code class="highlighter-rouge">V</code> all (i) support <code class="highlighter-rouge">B</code> (ii) know that <code class="highlighter-rouge">B</code> is well-supported, and so none of them can legally switch over unless enough others switch over first. For some competing <code class="highlighter-rouge">B'</code> to beat out <code class="highlighter-rouge">B</code>, the support such a <code class="highlighter-rouge">B'</code> can <em>legally</em> have is initially at most <code class="highlighter-rouge">1-p</code> (everyone not part of the clique), and to win the LMD GHOST fork choice its support needs to get to <code class="highlighter-rouge">1/2</code>, so at least <code class="highlighter-rouge">1/2 - (1-p) = p - 1/2</code> need to illegally switch over to get it to the point where the LMD GHOST rule supports <code class="highlighter-rouge">B'</code>.</p>

<p>As a specific case, note that the <code class="highlighter-rouge">p=3/4</code> clique oracle offers a <code class="highlighter-rouge">1/4</code> level of safety, and a set of blocks satisfying the clique can (and in normal operation, will) be generated as long as <code class="highlighter-rouge">3/4</code> of nodes are online. Hence, in a BFT sense, the level of fault tolerance that can be reached using two-round clique oracles is <code class="highlighter-rouge">1/4</code>, in terms of both liveness and safety.</p>

<p>This approach to consensus has many nice benefits. First of all, the 
short-term chain selection algorithm, and the “finality algorithm”, are 
not two awkwardly glued together distinct components, as they admittedly
 are in Casper FFG; rather, they are both part of the same coherent 
whole. Second, because safety detection is client-side, there is no need
 to choose any thresholds in-protocol; clients can decide for themselves
 what level of safety is sufficient to consider a block as finalized.</p>

<h3 id="going-further">Going Further</h3>

<p>CBC can be extended further in many ways. First, one can come up with
 other safety oracles; higher-round clique oracles can reach <code class="highlighter-rouge">1/3</code>
 fault tolerance. Second, we can add validator rotation mechanisms. The 
simplest is to allow the validator set to change by a small percentage 
every time the <code class="highlighter-rouge">q=3/4</code> clique 
oracle is satisfied, but there are other things that we can do as well. 
Third, we can go beyond chain-like structures, and instead look at 
structures that increase the density of messages per unit time, like the
 Serenity beacon chain’s attestation structure:</p>

<center>
<img src="A%20CBC%20Casper%20Tutorial-Dateien/Chain13.png"><br>
</center>
<p><br></p>

<p>In this case, it becomes worthwhile to separate <em>attestations</em> from <em>blocks</em>;
 a block is an object that actually grows the underlying DAG, whereas an
 attestation contributes to the fork choice rule. In the <a href="http://github.com/ethereum/eth2.0-specs">Serenity beacon chain spec</a>,
 each block may have hundreds of attestations corresponding to it. 
However, regardless of which way you do it, the core logic of CBC Casper
 remains the same.</p>

<p>To make CBC Casper’s safety “cryptoeconomically enforceable”, we need
 to add validity and slashing conditions. First, we’ll start with the 
validity rule. A block contains both a parent block and a set of 
attestations that it knows about that are not yet part of the chain 
(similar to “uncles” in the current Ethereum PoW chain). For the block 
to be valid, the block’s parent must be the result of executing the LMD 
GHOST fork choice rule given the information included in the chain 
including in the block itself.</p>

<center>
<img src="A%20CBC%20Casper%20Tutorial-Dateien/Chain14.png"><br>
<small><i>Dotted lines are uncle links, eg. when E creates a block, E 
notices that C is not yet part of the chain, and so includes a reference
 to C.</i></small>
</center>

<p><br></p>

<p>We now can make CBC Casper safe with only one slashing condition: you
 cannot make two attestations M1 and M2, unless either M1 is in the 
chain that M2 is attesting to or M2 is in the chain that M1 is attesting
 to.</p>

<center>
<table style="text-align:center" cellpadding="20px"><tbody><tr>
<td><img src="A%20CBC%20Casper%20Tutorial-Dateien/Chain15.png" width="280px"><br>OK</td>
<td><img src="A%20CBC%20Casper%20Tutorial-Dateien/Chain16.png" width="280px"><br>Not OK</td>
</tr></tbody></table>
</center>

<p>The validity and slashing conditions are relatively easy to describe,
 though actually implementing them requires checking hash chains and 
executing fork choice rules in-consensus, so it is not nearly as simple 
as taking two messages and checking a couple of inequalities between the
 numbers that these messages commit to, as you can do in Casper FFG for 
the <code class="highlighter-rouge">NO_SURROUND</code> and <code class="highlighter-rouge">NO_DBL_VOTE</code> <a href="https://ethresear.ch/t/beacon-chain-casper-ffg-rpj-mini-spec/2760">slashing conditions</a>.</p>

<p>Liveness in CBC Casper piggybacks off of the liveness of whatever the
 underlying chain algorithm is (eg. if it’s one-block-per-slot, then it 
depends on a synchrony assumption that all nodes will see everything 
produced in slot N before the start of slot N+1). It’s not possible to 
get “stuck” in such a way that one cannot make progress; it’s possible 
to get to the point of finalizing new blocks from any situation, even 
one where there are attackers and/or network latency is higher than that
 required by the underlying chain algorithm.</p>

<p>Suppose that at some time T, the network “calms down” and synchrony 
assumptions are once again satisfied. Then, everyone will converge on 
the same view of the chain, with the same head H. From there, validators
 will begin to sign messages supporting H or descendants of H. From 
there, the chain can proceed smoothly, and will eventually satisfy a 
clique oracle, at which point H becomes finalized.</p>

<center>
<img src="A%20CBC%20Casper%20Tutorial-Dateien/Chain17.png" height="100px"><br>
<small><i>Chaotic network due to high latency.</i></small>
</center>
<p><br></p>
<center>
<img src="A%20CBC%20Casper%20Tutorial-Dateien/Chain18.png" height="100px"><br>
<small><i>Network latency subsides, a majority of validators see all of 
the same blocks or at least enough of them to get to the same head when 
executing the fork choice, and start building on the head, further 
reinforcing its advantage in the fork choice rule.</i></small>
</center>
<p><br></p>
<center>
<img src="A%20CBC%20Casper%20Tutorial-Dateien/Chain19.png" height="100px"><br>
<small><i>Chain proceeds "peacefully" at low latency. Soon, a clique oracle will be satisfied.</i></small>
</center>
<p><br></p>

<p>That’s all there is to it! Implementation-wise, CBC may arguably be 
considerably more complex than FFG, but in terms of ability to reason 
about the protocol, and the properties that it provides, it’s 
surprisingly simple.</p>

  </div>

</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Vitalik Buterin's website</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Vitalik Buterin's website</li>
          <li><a href="mailto:"></a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/vbuterin"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"></path></svg>
</span><span class="username">vbuterin</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/VitalikButerin"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"></path></svg>
</span><span class="username">VitalikButerin</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>All content written by me is by default released freely under the <a href="http://www.wtfpl.net/">WTFPL</a>.
</p>
      </div>
    </div>

  </div>

</footer>


  


</body></html>